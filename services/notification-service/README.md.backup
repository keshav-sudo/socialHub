# Notification Service

## Overview
Handles real-time notifications for users, consuming events from Post and Chat services. Supports push notifications, in-app notifications, and email notifications.

## Architecture

```
Post Service → Kafka → Notification Service → PostgreSQL (notifications)
                                            → RabbitMQ (consume events)
                                            → WebSocket (push to clients)
                                            → Email Service
                                            
Chat Service → RabbitMQ → Notification Service
```

## Technology Stack
- **Runtime**: Node.js + TypeScript
- **Framework**: Express.js
- **Database**: MongoDB via Prisma (not PostgreSQL)
- **Message Queue**: Kafka (consuming post/user events)
- **Real-time**: Planned (WebSocket / SSE)
- **Email**: Planned (Nodemailer / SendGrid)

## Port
- **5002**: HTTP REST API

## Database Schema (Prisma + MongoDB)

### Notifications Model
```prisma
model Notifications {
  id            String           @id @default(auto()) @map("_id") @db.ObjectId
  userId        String
  username      String?
  postId        String?
  commentId     String?
  likeId        String?
  followerId    String?
  followingId   String?
  type          NotificationType
  triggeredById String
  message       String
  link          String?
  is_read       Boolean          @default(false)
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt
}

enum NotificationType {
  POST
  CONNECTION
  ENGAGEMENT
  PROFILE
}
```

**Note**: MongoDB is used for flexible schema and high-volume writes.

## API Endpoints

### 1. Get User Notifications
```http
GET /notify/notifications
Authorization: Bearer <token>

Response:
{
  "success": true,
  "message": "Fetched and marked 10 notifications as read.",
  "data": [
    {
      "id": "notif-id",
      "type": "ENGAGEMENT",
      "message": "New comment on your post!",
      "username": "john_doe",
      "triggeredById": "user-uuid",
      "postId": "post-id",
      "commentId": "comment-id",
      "is_read": true,
      "createdAt": "2024-10-14T06:30:00Z"
    }
  ]
}
```

**Note**: This endpoint automatically marks all fetched notifications as read. It returns the last 50 unread notifications.

**Note**: Currently, the service only implements the GET notifications endpoint. Other endpoints (mark as read, delete, preferences) are planned for future implementation.
```http
PATCH /notify/notifications/:id/read
Authorization: Bearer <token>

Response:
{
  "success": true,
  "message": "Notification marked as read"
}
```

#### 3. Mark All as Read
```http
PATCH /notify/notifications/read-all
Authorization: Bearer <token>

Response:
{
  "success": true,
  "message": "All notifications marked as read",
  "count": 25
}
```

#### 4. Delete Notification
```http
DELETE /notify/notifications/:id
Authorization: Bearer <token>

Response:
{
  "success": true,
  "message": "Notification deleted"
}
```

#### 5. Get Notification Preferences
```http
GET /notify/preferences
Authorization: Bearer <token>

Response:
{
  "success": true,
  "preferences": {
    "emailNotifications": true,
    "pushNotifications": true,
    "inAppNotifications": true,
    "notificationTypes": {
      "likes": true,
      "comments": true,
      "follows": true,
      "messages": true,
      "mentions": false
    }
  }
}
```

#### 6. Update Notification Preferences
```http
PATCH /notify/preferences
Authorization: Bearer <token>
Content-Type: application/json

{
  "emailNotifications": false,
  "pushNotifications": true,
  "notificationTypes": {
    "likes": true,
    "comments": true,
    "follows": false
  }
}

Response:
{
  "success": true,
  "message": "Preferences updated"
}
```

#### 7. Get Unread Count
```http
GET /notify/notifications/unread/count
Authorization: Bearer <token>

Response:
{
  "success": true,
  "count": 25
}
```

## Environment Variables

```env
# Server
PORT=5002
NODE_ENV=production

# Database
DATABASE_URL=postgresql://user:password@postgres:5432/notifications_db

# Kafka
KAFKA_BROKERS=kafka:9092
KAFKA_GROUP_ID=notification-service
KAFKA_TOPIC_NEW_POST=new_post
KAFKA_TOPIC_POST_UPDATED=post_updated

# RabbitMQ
RABBITMQ_URL=amqp://rabbitmq:5672
RABBITMQ_QUEUE_NEW_MESSAGE=new_message
RABBITMQ_QUEUE_NEW_FOLLOW=new_follow

# Email
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=notifications@yourdomain.com
SMTP_PASS=your-app-password
FROM_EMAIL=notifications@yourdomain.com

# Push Notifications (FCM)
FCM_SERVER_KEY=your-fcm-server-key

# Auth Service
AUTH_SERVICE_URL=auth-service:50051

# WebSocket (if implementing)
WS_PORT=5002
```

## Event Consumers

### 1. Kafka Consumer - New Post Event
```javascript
// Topic: new_post
{
  "eventType": "post.created",
  "data": {
    "postId": "post-id",
    "userId": "user-uuid",
    "username": "john_doe",
    "content": "Post content"
  }
}

// Action: Notify all followers
```

### 2. RabbitMQ Consumer - New Message Event
```javascript
// Queue: new_message
{
  "eventType": "message.sent",
  "data": {
    "messageId": "msg-id",
    "senderId": "user-uuid",
    "receiverId": "user-uuid-2",
    "message": "Hello!"
  }
}

// Action: Send notification to receiver
```

### 3. RabbitMQ Consumer - New Follow Event
```javascript
// Queue: new_follow
{
  "eventType": "user.followed",
  "data": {
    "followerId": "user-uuid",
    "followerUsername": "jane_doe",
    "followingId": "user-uuid-2"
  }
}

// Action: Notify the followed user
```

## Notification Types

### Post Notifications
- **New Post**: "user123 posted something new"
- **Post Like**: "user123 liked your post"
- **Post Comment**: "user123 commented on your post"
- **Post Mention**: "user123 mentioned you in a post"

### Social Notifications
- **New Follower**: "user123 started following you"
- **Follow Back**: "user123 followed you back"

### Chat Notifications
- **New Message**: "user123 sent you a message"
- **Group Message**: "user123 messaged in GroupName"

### System Notifications
- **Welcome**: "Welcome to SocialHub!"
- **Security**: "New login detected from New York"

## Testing APIs

### Using cURL

```bash
TOKEN="your-jwt-token-here"

# 1. Get notifications
curl -X GET "http://localhost/notify/notifications?page=1&limit=20" \
  -H "Authorization: Bearer $TOKEN"

# 2. Get unread count
curl -X GET http://localhost/notify/notifications/unread/count \
  -H "Authorization: Bearer $TOKEN"

# 3. Mark notification as read
curl -X PATCH http://localhost/notify/notifications/notif-id/read \
  -H "Authorization: Bearer $TOKEN"

# 4. Mark all as read
curl -X PATCH http://localhost/notify/notifications/read-all \
  -H "Authorization: Bearer $TOKEN"

# 5. Get preferences
curl -X GET http://localhost/notify/preferences \
  -H "Authorization: Bearer $TOKEN"

# 6. Update preferences
curl -X PATCH http://localhost/notify/preferences \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "emailNotifications": false,
    "pushNotifications": true
  }'

# 7. Delete notification
curl -X DELETE http://localhost/notify/notifications/notif-id \
  -H "Authorization: Bearer $TOKEN"
```

## Notification Delivery Channels

### 1. In-App Notifications
- Stored in PostgreSQL
- Retrieved via REST API
- Real-time via WebSocket (future)

### 2. Email Notifications
```javascript
// Email template
Subject: You have a new follower!
Body: john_doe started following you on SocialHub.
```

### 3. Push Notifications (Future)
- Firebase Cloud Messaging (FCM)
- Apple Push Notification Service (APNS)
- Web Push API

## Consumer Implementation

### Kafka Consumer Setup
```javascript
const consumer = kafka.consumer({ 
  groupId: 'notification-service' 
});

await consumer.subscribe({ 
  topic: 'new_post', 
  fromBeginning: false 
});

await consumer.run({
  eachMessage: async ({ topic, partition, message }) => {
    const event = JSON.parse(message.value);
    await handleNewPostEvent(event);
  }
});
```

### RabbitMQ Consumer Setup
```javascript
const connection = await amqp.connect(process.env.RABBITMQ_URL);
const channel = await connection.createChannel();
await channel.assertQueue('new_message');

channel.consume('new_message', async (msg) => {
  const event = JSON.parse(msg.content.toString());
  await handleNewMessageEvent(event);
  channel.ack(msg);
});
```

## Business Logic

### Create Notification Flow
1. Receive event from Kafka/RabbitMQ
2. Extract user IDs to notify (e.g., all followers)
3. Check user notification preferences
4. Create notification records in database
5. Send email if enabled
6. Send push notification if enabled
7. Broadcast via WebSocket if user is online

### Performance Optimization
- Batch insert notifications for multiple users
- Async email sending (queue)
- Cache user preferences in Redis
- Paginate notification list
- Archive old notifications (30+ days)

## Security

- **Authentication**: All endpoints require valid JWT
- **Authorization**: Users can only access their own notifications
- **Rate Limiting**: 100 requests per minute per user
- **SQL Injection**: Parameterized queries
- **XSS Protection**: Sanitize notification content

## Error Codes

- **400**: Bad Request (invalid parameters)
- **401**: Unauthorized (invalid token)
- **403**: Forbidden (not notification owner)
- **404**: Not Found (notification not found)
- **429**: Too Many Requests (rate limit)
- **500**: Internal Server Error

## Monitoring & Health Check

```bash
curl http://localhost:5002/health

Response:
{
  "status": "ok",
  "service": "notification-service",
  "timestamp": "2024-10-14T06:30:00Z",
  "database": "connected",
  "kafka": "connected",
  "rabbitmq": "connected"
}
```

## Development

```bash
# Install dependencies
npm install

# Run in development mode
npm run dev

# Run consumers
npm run consumers

# Build
npm run build

# Run in production
npm start

# Run tests
npm test

# Run database migrations
npx prisma migrate dev
```

## Dependencies

```json
{
  "express": "^4.18.2",
  "pg": "^8.11.3",
  "@prisma/client": "^5.7.0",
  "kafkajs": "^2.2.4",
  "amqplib": "^0.10.3",
  "nodemailer": "^6.9.7",
  "ioredis": "^5.3.2",
  "@grpc/grpc-js": "^1.9.13",
  "joi": "^17.11.0"
}
```

## Database Queries

### Get User Notifications with Pagination
```sql
SELECT * FROM notifications
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3;
```

### Get Unread Count
```sql
SELECT COUNT(*) FROM notifications
WHERE user_id = $1 AND is_read = FALSE;
```

### Mark All as Read
```sql
UPDATE notifications
SET is_read = TRUE, read_at = NOW()
WHERE user_id = $1 AND is_read = FALSE;
```

## Future Enhancements

- Real-time WebSocket notifications
- Push notifications (FCM, APNS)
- Notification grouping (e.g., "5 people liked your post")
- Digest emails (daily/weekly summary)
- Notification scheduling
- Rich notifications with images
- Custom notification sounds
- Do Not Disturb mode
- Notification analytics
- A/B testing for notification content
